/*=========================================================================
*
*  Copyright Insight Software Consortium
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*         http://www.apache.org/licenses/LICENSE-2.0.txt
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*=========================================================================*/
$(include DoNotEditWarning.cxx.in)

$(include StandardIncludes.cxx.in)
$(include AddExtraIncludes.cxx.in)

namespace itk {
namespace simple {

//-----------------------------------------------------------------------------

//
// Default constructor that initializes parameters
//
$(include ConstructorSignature.cxx.in)
{
$(include ConstructorInitializeMembers.cxx.in)
$(include ConstructorMemberFunctionSetup.cxx.in)

$(include ConstructorVectorPixels.cxx.in)
}

//
// ToString
//
$(include ToStringSignature.cxx.in)
{
$(include ToStringBody.cxx.in)
$(include ToStringReturn.cxx.in)
}

//-----------------------------------------------------------------------------

//
// Execute
//
$(if members and #members > 0 then
OUT = [[

Image ${name}ImageFilter::Execute ( std::vector<Image> &images$(include MemberParameters.in) )
{
$(foreach members
$(if (not no_set_method) or (no_set_method == 0) then
OUT = '  this->Set${name} ( in${name} );'
end)
)
  return this->Execute ( images );
}


Image ${name}ImageFilter::Execute ( const Image& image1$(include MemberParameters.in) )
  {
  std::vector<Image> images;
  images.push_back( image1 );
  return this->Execute( images$(for i = 1,#members do
                        OUT= OUT .. ', in' .. members[i].name
                          end) );
  }


Image ${name}ImageFilter::Execute ( const Image& image1, const Image& image2$(include MemberParameters.in) )
  {
  std::vector<Image> images;
  images.push_back( image1 );
  images.push_back( image2 );
  return this->Execute( images$(for i = 1,#members do
                        OUT= OUT .. ', in' .. members[i].name
                          end) );
  }


Image ${name}ImageFilter::Execute ( const Image& image1, const Image& image2, const Image& image3$(include MemberParameters.in) )
  {
  std::vector<Image> images;
  images.push_back( image1 );
  images.push_back( image2 );
  images.push_back( image3 );
  return this->Execute( images$(for i = 1,#members do
                        OUT= OUT .. ', in' .. members[i].name
                          end) );
  }

]]
end)


Image ${name}ImageFilter::Execute ( const Image& image1 )
{
  std::vector<Image> images;
  images.push_back( image1 );
  return this->Execute( images );
}

Image ${name}ImageFilter::Execute ( const Image& image1, const Image& image2 )
{
  std::vector<Image> images;
  images.push_back( image1 );
  images.push_back( image2 );
  return this->Execute( images );
}

Image ${name}ImageFilter::Execute ( const Image& image1, const Image& image2, const Image& image3 )
{
  std::vector<Image> images;
  images.push_back( image1 );
  images.push_back( image2 );
  images.push_back( image3 );
  return this->Execute( images );
}

Image ${name}ImageFilter::Execute ( std::vector<Image> &images )
{
  if ( images.empty() )
    {
    sitkExceptionMacro( "Atleast one input is required" );
    }

  PixelIDValueType type = images.front().GetPixelIDValue();
  unsigned int dimension = images.front().GetDimension();

  for( std::vector<Image>::const_iterator i = images.begin(); i != images.end(); ++i )
    {
    if ( type != i->GetPixelIDValue() ||
         dimension != i->GetDimension() )
      {
      sitkExceptionMacro ( "An image for ${name}ImageFilter doesnt match type or dimension!" );
      }
    }

    return this->m_MemberFactory->GetMemberFunction( type, dimension )( images );
}

//-----------------------------------------------------------------------------

//
// ExecuteInternal
//
template <class TImageType>
Image ${name}ImageFilter::ExecuteInternal ( std::vector<Image> &images )
{
$(include ExecuteInternalTypedefs.cxx.in)


$(include ExecuteInternalITKFilter.cxx.in)

  for ( unsigned int i = 0; i < images.size(); ++i )
    {
    // Get the pointer to the ITK image contained in image1
    typename InputImageType::ConstPointer image = this->CastImageToITK<InputImageType>( images[i] );

    filter->SetInput( i, image );
    }

$(include ExecuteInternalSetITKFilterParameters.cxx.in)

$(include ExecuteInternalUpdateAndReturn.cxx.in)
 }

//
// Function to run the Execute method of this filter
//
Image ${name} ( std::vector<Image> & images$(include MemberParameters.in) )
{
  ${name}ImageFilter filter;
  return filter.Execute ( images$(for i = 1,#members do
                          OUT= OUT .. ', in' .. members[i].name
                          end) );
}

Image ${name} ( const Image &image1$(include MemberParameters.in) )
{
  ${name}ImageFilter filter;
  return filter.Execute ( image1$(for i = 1,#members do
                          OUT= OUT .. ', in' .. members[i].name
                          end) );
}

Image ${name} ( const Image &image1, const Image &image2$(include MemberParameters.in) )
{
  ${name}ImageFilter filter;
  return filter.Execute ( image1, image2$(for i = 1,#members do
                          OUT= OUT .. ', in' .. members[i].name
                          end) );
}

Image ${name} ( const Image &image1, const Image &image2, const Image &image3$(include MemberParameters.in) )
{
  ${name}ImageFilter filter;
  return filter.Execute ( image1, image2, image3$(for i = 1,#members do
                          OUT= OUT .. ', in' .. members[i].name
                          end) );
}


} // end namespace simple
} // end namespace itk
