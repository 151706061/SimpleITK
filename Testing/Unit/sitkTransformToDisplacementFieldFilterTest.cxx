/*=========================================================================
*
*  Copyright Insight Software Consortium
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*         http://www.apache.org/licenses/LICENSE-2.0.txt
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*=========================================================================*/
/*
 * WARNING: DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED BY THE SIMPLEITK BUILD PROCESS.
 * Please look at sitkImageFilterTestTemplate.cxx.in to make changes.
 */

#include <SimpleITKTestHarness.h>

#include <sitkTransformToDisplacementFieldFilter.h>
#include <sitkImageFileReader.h>
#include <sitkImageFileWriter.h>
#include <sitkHashImageFilter.h>
#include <sitkCastImageFilter.h>
#include <sitkVersion.h>


TEST(BasicFilters,TransformToDisplacementFieldFilter) {
  itk::simple::ImageFileReader reader;
  itk::simple::TransformToDisplacementFieldFilter filter;
  itk::simple::Image inputA( 0, 0, itk::simple::sitkUInt8 );
  itk::simple::Image inputB( 0, 0, itk::simple::sitkUInt8 );
  itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );
  std::string inputSHA1hash;

  

  EXPECT_EQ ( filter.GetOutputPixelType(), itk::simple::sitkVectorFloat64 ) << "Testing get for OutputPixelType";
  for(unsigned int i = 0; i < filter.GetSize().size(); ++i)
    {
    EXPECT_EQ ( filter.GetSize()[i], std::vector<unsigned int>(3, 64)[i] ) << "Testing get for Size at " << i;
    }
  for(unsigned int i = 0; i < filter.GetOutputOrigin().size(); ++i)
    {
    EXPECT_EQ ( filter.GetOutputOrigin()[i], std::vector<double>(3, 0.0)[i] ) << "Testing get for OutputOrigin at " << i;
    }
  for(unsigned int i = 0; i < filter.GetOutputSpacing().size(); ++i)
    {
    EXPECT_EQ ( filter.GetOutputSpacing()[i], std::vector<double>(3, 1.0)[i] ) << "Testing get for OutputSpacing at " << i;
    }
  EXPECT_EQ ( filter.GetOutputDirection(), std::vector<double>() ) << "Testing get for OutputDirection";

  EXPECT_NE ( filter.ToString(), "" ) << "empty ToString method!";
  EXPECT_EQ ( filter.GetName(), "TransformToDisplacementFieldFilter" ) << "checking GetName method!";

  // Test sets / gets
  filter.SetOutputPixelType ( itk::simple::sitkVectorFloat64 );
  EXPECT_EQ ( filter.GetOutputPixelType(), itk::simple::sitkVectorFloat64 ) << "Testing set/get for OutputPixelType";
  filter.SetSize ( std::vector<unsigned int>(3, 64) );
  for(unsigned int i = 0; i < filter.GetSize().size(); ++i)
    {
    EXPECT_EQ ( filter.GetSize()[i], std::vector<unsigned int>(3, 64)[i] ) << "Testing set/get for Size at " << i;
    }
  filter.SetOutputOrigin ( std::vector<double>(3, 0.0) );
  for(unsigned int i = 0; i < filter.GetOutputOrigin().size(); ++i)
    {
    EXPECT_EQ ( filter.GetOutputOrigin()[i], std::vector<double>(3, 0.0)[i] ) << "Testing set/get for OutputOrigin at " << i;
    }
  filter.SetOutputSpacing ( std::vector<double>(3, 1.0) );
  for(unsigned int i = 0; i < filter.GetOutputSpacing().size(); ++i)
    {
    EXPECT_EQ ( filter.GetOutputSpacing()[i], std::vector<double>(3, 1.0)[i] ) << "Testing set/get for OutputSpacing at " << i;
    }
  filter.SetOutputDirection ( std::vector<double>() );
  EXPECT_EQ ( filter.GetOutputDirection(), std::vector<double>() ) << "Testing set/get for OutputDirection";






 
}

TEST(BasicFilters,TransformToDisplacementFieldFilter_defaults)
  { // BEGIN FOR EACH TEST
  /* TAG: defaults DESCRIPTION: Simply run with default settings */

  itk::simple::ImageFileReader reader;
  itk::simple::TransformToDisplacementFieldFilter filter;
  itk::simple::Image output;
  itk::simple::HashImageFilter hasher;
  std::string inputSHA1hash;

  std::vector<itk::simple::Image> inputs;
  std::vector<std::string> inputFileNames;

  inputFileNames.push_back( "Input/RA-Slice-Float.nrrd"  );


  for ( unsigned int i = 0; i < inputFileNames.size(); ++i )
    {
    ASSERT_NO_THROW ( inputs.push_back( reader.SetFileName ( dataFinder.GetFile ( inputFileNames[i]  ) ).Execute() ) ) << "Failed to load " << inputFileNames[i] << " from " << dataFinder.GetFile ( inputFileNames[i]  );


    ASSERT_TRUE ( inputs[i].GetITKBase() != NULL ) << "Could not read " << inputFileNames[i];
    }

    if ( !inputs.empty() )
      {
      inputSHA1hash =  itk::simple::Hash( inputs[0] );
      }

  
      // Do we get the same image back, if we use the functional interface?
      itk::simple::Image fromFunctional( 0, 0, itk::simple::sitkUInt8 );
      itk::simple::Image fromProcedural( 0, 0, itk::simple::sitkUInt8 );
      ASSERT_NO_THROW ( fromProcedural = filter.Execute ( inputs[0]  ) ) << "Procedural interface to TransformToDisplacementFieldFilter";
      ASSERT_NO_THROW ( fromFunctional = itk::simple::TransformToDisplacementField ( inputs[0] 
                                                                       
                                                                       
                                                                       
                                                                       itk::simple::sitkVectorFloat64, std::vector<unsigned int>(3, 64), std::vector<double>(3, 0.0), std::vector<double>(3, 1.0), std::vector<double>()


                                                                      ) ) << "Functional interface to TransformToDisplacementFieldFilter";
      hasher.SetHashFunction ( itk::simple::HashImageFilter::MD5 );
      EXPECT_EQ ( hasher.Execute ( fromProcedural ), hasher.Execute ( fromFunctional ) ) << "procedural and functional are not the same!";






   filter.DebugOn();
   ASSERT_NO_THROW ( output =  filter.Execute ( inputs[0]  ) );

  if ( !inputs.empty() )
      {
      // Check that the input is not modified
      // This will fail if the filter is being run in-place
      EXPECT_EQ ( inputSHA1hash,  itk::simple::Hash( inputs[0] ) ) << "Input was modified by filter.";
      }

  
    IMAGECOMPAREWITHTOLERANCE ( output, "", 5e-4 );
  


} // END FOR EACH TEST



#if defined(WRAP_LUA)

TEST_F(Lua,TransformToDisplacementFieldFilter) {
  

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/LuaTests/TransformToDisplacementFieldFilterTest.lua";
      {
    /* Simply run with default settings */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Lua-TransformToDisplacementFieldFilter-defaults.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetLuaExecutable();
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "defaults" );
  CommandLine.push_back( dataFinder.GetFile ("Input/RA-Slice-Float.nrrd")  );

    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";

      ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";
  

    
    
                  IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "defaults", 5e-4 );
               
      }
    
}
#endif

#if defined(WRAP_PYTHON)

TEST_F(Python,TransformToDisplacementFieldFilter) {
  

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/PythonTests/TransformToDisplacementFieldFilterTest.py";
      {
    /* Simply run with default settings */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Python-TransformToDisplacementFieldFilter-defaults.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetPythonExecutable();
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "defaults" );
  CommandLine.push_back( dataFinder.GetFile ("Input/RA-Slice-Float.nrrd")  );

    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";

      ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";


    
    
                  IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "defaults", 5e-4 );
               
      }
    
}
#endif

#if defined(WRAP_TCL)

TEST_F(Tcl,TransformToDisplacementFieldFilter) {
  

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/TclTests/TransformToDisplacementFieldFilterTest.tcl";
      {
    /* Simply run with default settings */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Tcl-TransformToDisplacementFieldFilter-defaults.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetTclExecutable ( );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "defaults" );
  CommandLine.push_back( dataFinder.GetFile ("Input/RA-Slice-Float.nrrd")  );

    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";

      ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";
  

    
    
                  IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "defaults", 5e-4 );
               
      }
    
}
#endif

#if defined(WRAP_R)

TEST_F(R,TransformToDisplacementFieldFilter) {
  

  // Set-up the R enviroment to include the SimpleITK R library in the
  // build directory.
  SetEnvironment ( "R_LIBS", dataFinder.GetBuildDirectory()+"/Wrapping/RLib" );


  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/RTests/TransformToDisplacementFieldFilterTest.R";
      {

    /* Simply run with default settings */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "R-TransformToDisplacementFieldFilter-defaults.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetRExecutable();
    CommandLine.push_back ( "--slave" );
    CommandLine.push_back ( "--vanilla" );
    CommandLine.push_back ( std::string("--file=")+Script );
    CommandLine.push_back ( "--args" );
    CommandLine.push_back ( "defaults" );
  CommandLine.push_back( dataFinder.GetFile ("Input/RA-Slice-Float.nrrd")  );

    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";

      ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );
    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";


    
    
                  IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "defaults", 5e-4 );
               
      }

    
}
#endif



#if defined(WRAP_JAVA)

TEST_F(Java,TransformToDisplacementFieldFilter) {
  

  std::string Classpath = dataFinder.GetBuildDirectory() + "/Testing/Unit/JavaTests"
    + dataFinder.GetPathSeparator() + dataFinder.GetBuildDirectory() + "/Wrapping/simpleitk-" + itk::simple::Version::VersionString() + ".jar";
  std::string JavaPath = dataFinder.GetLibraryDirectory();
  std::string Script = "org.itk.simple.testing.TransformToDisplacementFieldFilterTest";
      {
    /* Simply run with default settings */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Java-TransformToDisplacementFieldFilter-defaults.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetJavaExecutable();
    CommandLine.push_back ( "-classpath" );
    CommandLine.push_back ( Classpath );
    CommandLine.push_back ( "-Djava.library.path=" + JavaPath );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "defaults" );
  CommandLine.push_back( dataFinder.GetFile ("Input/RA-Slice-Float.nrrd")  );

    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";

      ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );
    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";


    
    
                  IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "defaults", 5e-4 );
               
      }
    
}
#endif

#if defined(WRAP_RUBY)

TEST_F(Ruby,TransformToDisplacementFieldFilter) {
  

  // Set our Ruby path
  SetEnvironment ( "RUBYLIB", dataFinder.GetLibraryDirectory() );

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/RubyTests/TransformToDisplacementFieldFilterTest.rb";
      {
    /* Simply run with default settings */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Ruby-TransformToDisplacementFieldFilter-defaults.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetRubyExecutable();
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "defaults" );
  CommandLine.push_back( dataFinder.GetFile ("Input/RA-Slice-Float.nrrd")  );

    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";

      ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );
    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";


    
    
                  IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "defaults", 5e-4 );
               
      }
    
}
#endif

#if defined(WRAP_CSHARP)

TEST_F(CSharp,TransformToDisplacementFieldFilter) {
  

  std::string ExePath = dataFinder.GetCSharpBinaryDirectory();
  std::string ExeName = "TestTransformToDisplacementFieldFilter.exe";
  std::string ExePathAndName = ExePath + "/" + ExeName;

  // On Linux, we need to specify where the shared library is found
  std::string path = dataFinder.GetBuildDirectory() + "/Wrapping/CSharpBinaries";
  SetEnvironment ( "LD_LIBRARY_PATH", path );


      {
    /* Simply run with default settings */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "CSharp-TransformToDisplacementFieldFilter-defaults.nrrd" );

    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }

    std::vector<std::string> cs_interp = dataFinder.GetCSharpInterpreter();

    if ( cs_interp.size() && cs_interp[0].size() )
    {
      CommandLine = dataFinder.GetCSharpInterpreter();
    }
    CommandLine.push_back ( ExePathAndName );
    CommandLine.push_back ( dataFinder.GetFile ( "Input/RA-Short.nrrd" ).c_str() );
    CommandLine.push_back ( "defaults" );
  CommandLine.push_back( dataFinder.GetFile ("Input/RA-Slice-Float.nrrd")  );

    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";

      ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    itk::simple::ImageFileReader reader;
    itk::simple::HashImageFilter hasher;
    itk::simple::Image output( 0, 0, itk::simple::sitkUInt8 );
    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";


    
    
                  IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "defaults", 5e-4 );
               
      }
    
}
#endif
